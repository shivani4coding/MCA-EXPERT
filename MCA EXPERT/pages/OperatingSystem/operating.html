<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>www.operating.com</title>
    <link rel="stylesheet" href="../../css/customer.css">
    <script src="../../js/jquery-3.2.1.js"></script>
    <link rel="stylesheet" href="../../bootstrap-3.3.7-dist/css/bootstrap.min.css">
    <script src="../../bootstrap-3.3.7-dist/js/bootstrap.min.js"></script>
</head>
<body class="container">
        
 <div id="container">
          <div id="topdiv"> <img src="../../images/index-img/globe%20(1).gif" alt="">
          <div id="topleft"><!--hello--></div>
         <b><h1> MCA EXPERT</h1></b>
         
         <!--<marquee behavior="alternate" direction="">MCA EXPERT <img src="../images/index-img/smallcollege.jpg" alt=""></marquee>-->
          </div>
      </div>
  
<div id="container1">
           <div id="wrapper1">
                <ul>
               <li><a href="#/">Home</a></li>
               <li><a href="#/tutorial">Tutorial</a></li>
               <li><a href="#">Interview Questions</a></li>
               <li><a href="#">Programs</a></li>
               <li><a href="#">Contact Us</a></li>
           </ul>
           </div>
       </div>
<h2>Operating System</h2>
 <p>An operating system (OS) is a collection of software that manages computer hardware resources and provides common services for computer programs. The operating system is a vital component of the system software in a computer system.An operating system is a program that acts as an interface between the user and the computer hardware and controls the execution of all kinds of programs .</p>

<h2>Functions of an operating System</h2>

Memory Management <br>
Processor Management <br>
Device Management <br>
File Management <br>
Security <br>
Control over system performance <br>
Job accounting <br>
Error detecting aids <br>
Coordination between other software and users <br>
<h3>Memory Management</h3>
Memory management refers to management of Primary Memory or Main Memory. Main memory is a large array of words or bytes where each word or byte has its own address. Main memory provides a fast storage that can be accessed directly by the CPU. For a program to be executed, it must in the main memory. An Operating System does the following activities for memory management -

Keeps tracks of primary memory, i.e., what part of it are in use by whom, what part are not in use. <br>

In multiprogramming, the OS decides which process will get memory when and how much. <br>

Allocates the memory when a process requests it to do so. <br>

De-allocates the memory when a process no longer needs it or has been terminated. <br>

<h3>Processor Management</h3>
In multiprogramming environment, the OS decides which process gets the processor when and for how much time. This function is called process scheduling. An Operating System does the following activities for processor management - <br>

Keeps tracks of processor and status of process. The program responsible for this task is known as traffic controller. <br>

Allocates the processor (CPU) to a process. <br>

De-allocates processor when a process is no longer required. <br>

<h3>Device Management</h3>
An Operating System manages device communication via their respective drivers. It does the following activities for device management - <br>

Keeps tracks of all devices. Program responsible for this task is known as the I/O controller. <br>

Decides which process gets the device when and for how much time. <br>

Allocates the device in the efficient way. <br>

De-allocates devices.

<h3>File Management</h3>
A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions. <br>

An Operating System does the following activities for file management - <br>

Keeps track of information, location, uses, status etc. The collective facilities are often known as file system. <br>

Decides who gets the resources. <br>

Allocates the resources. <br>

De-allocates the resources. <br>



<h2>Types of Operating System</h2>

Operating systems are there from the very first computer generation and they keep evolving with time. In this chapter, we will discuss some of the important types of operating systems which are most commonly used. <br>

<h3>Batch operating system</h3>
<p>The users of a batch operating system do not interact with the computer directly. Each user prepares his job on an off-line device like punch cards and submits it to the computer operator. To speed up processing, jobs with similar needs are batched together and run as a group. The programmers leave their programs with the operator and the operator then sorts the programs with similar requirements into batches. </p> <br>

The problems with Batch Systems are as follows -  <br>

Lack of interaction between the user and the job. <br>
CPU is often idle, because the speed of the mechanical I/O devices is slower than the CPU. <br>
Difficult to provide the desired priority. <br>

<h3>Time-sharing operating systems</h3>
Time-sharing is a technique which enables many people, located at various terminals, to use a particular computer system at the same time. Time-sharing or multitasking is a logical extension of multiprogramming. Processor's time which is shared among multiple users simultaneously is termed as time-sharing. <br>

The main difference between Multiprogrammed Batch Systems and Time-Sharing Systems is that in case of Multiprogrammed batch systems, the objective is to maximize processor use, whereas in Time-Sharing Systems, the objective is to minimize response time. <br>

Multiple jobs are executed by the CPU by switching between them, but the switches occur so frequently. Thus, the user can receive an immediate response. For example, in a transaction processing, the processor executes each user program in a short burst or quantum of computation. That is, if n users are present, then each user can get a time quantum. When the user submits the command, the response time is in few seconds at most. <br>

The operating system uses CPU scheduling and multiprogramming to provide each user with a small portion of a time. Computer systems that were designed primarily as batch systems have been modified to time-sharing systems. <br>

<h2>Advantages of Timesharing operating systems are as follows -</h2>

Provides the advantage of quick response. <br>
Avoids duplication of software. <br>
Reduces CPU idle time. <br>
<h2>Disadvantages of Time-sharing operating systems are as follows -</h2>

Problem of reliability. <br>
Question of security and integrity of user programs and data. <br>
Problem of data communication. <br>
Distributed operating System <br>
Distributed systems use multiple central processors to serve multiple real-time applications and multiple users. Data processing jobs are distributed among the processors accordingly. <br>

The processors communicate with one another through various communication lines (such as high-speed buses or telephone lines). These are referred as loosely coupled systems or distributed systems. Processors in a distributed system may vary in size and function. These processors are referred as sites, nodes, computers, and so on. <br>

<h3>The advantages of distributed systems are as follows -</h3>

With resource sharing facility, a user at one site may be able to use the resources available at another. <br>
Speedup the exchange of data with one another via electronic mail. <br>
If one site fails in a distributed system, the remaining sites can potentially continue operating. <br>
Better service to the customers. <br>
Reduction of the load on the host computer. <br>
Reduction of delays in data processing. <br>
<h3>Network operating System</h3>
<p>A Network Operating System runs on a server and provides the server the capability to manage data, users, groups, security, applications, and other networking functions. The primary purpose of the network operating system is to allow shared file and printer access among multiple computers in a network, typically a local area network (LAN), a private network or to other networks. <br>

Examples of network operating systems include Microsoft Windows Server 2003, Microsoft Windows Server 2008, UNIX, Linux, Mac OS X, Novell NetWare, and BSD.</p>

<Th3>he advantages of network operating systems are as follows -</Th3>

Centralized servers are highly stable. <br>
Security is server managed. <br>
Upgrades to new technologies and hardware can be easily integrated into the system. <br>
Remote access to servers is possible from different locations and types of systems. <br>

<h3>Advantages of network operating systems are as follows -</h3>

High cost of buying and running a server. <br>
Dependency on a central location for most operations. <br>
Regular maintenance and updates are required. <br>
<h2>Real Time operating System</h2>
<p>A real-time system is defined as a data processing system in which the time interval required to process and respond to inputs is so small that it controls the environment. The time taken by the system to respond to an input and display of required updated information is termed as the response time. So in this method, the response time is very less as compared to online processing.</p> <br>

<p>Real-time systems are used when there are rigid time requirements on the operation of a processor or the flow of data and real-time systems can be used as a control device in a dedicated application. A real-time operating system must have well-defined, fixed time constraints, otherwise the system will fail. For example, Scientific experiments, medical imaging systems, industrial control systems, weapon systems, robots, air traffic control systems, etc.</p> <br>

<h3>There are two types of real-time operating systems.</h3>

<h2>Hard real-time systems</h2>
Hard real-time systems guarantee that critical tasks complete on time. In hard real-time systems, secondary storage is limited or missing and the data is stored in ROM. In these systems, virtual memory is almost never found. <br>

<h2>Soft real-time systems</h2>
Soft real-time systems are less restrictive. A critical real-time task gets priority over other tasks and retains the priority until it completes. Soft real-time systems have limited utility than hard real-time systems. For example, multimedia, virtual reality, Advanced Scientific Projects like undersea exploration and planetary rovers, etc.  <br>



<h2>Operating System Scheduling algorithms</h2>
  
A Process Scheduler schedules different processes to be assigned to the CPU based on particular scheduling algorithms. There are six popular process scheduling algorithms which we are going to discuss in this chapter - <br>

First-Come, First-Served (FCFS) Scheduling <br>
Shortest-Job-Next (SJN) Scheduling <br>
Priority Scheduling <br>
Shortest Remaining Time <br>
Round Robin(RR) Scheduling <br>
Multiple-Level Queues Scheduling <br>


<h1>Multi-Threading</h1>

<h2>What is Thread?</h2>
A thread is a flow of execution through the process code, with its own program counter that keeps track of which instruction to execute next, system registers which hold its current working variables, and a stack which contains the execution history. <br>

A thread shares with its peer threads few information like code segment, data segment and open files. When one thread alters a code segment memory item, all other threads see that. <br>

A thread is also called a lightweight process. Threads provide a way to improve application performance through parallelism. Threads represent a software approach to improving performance of operating system by reducing the overhead thread is equivalent to a classical process. <br>

Each thread belongs to exactly one process and no thread can exist outside a process. Each thread represents a separate flow of control. Threads have been successfully used in implementing network servers and web server. They also provide a suitable foundation for parallel execution of applications on shared memory multiprocessors. The following figure shows the working of a single-threaded and a multithreaded process. <br>


<h2>File</h2>
A file is a named collection of related information that is recorded on secondary storage such as magnetic disks, magnetic tapes and optical disks. In general, a file is a sequence of bits, bytes, lines or records whose meaning is defined by the files creator and user. <br>

<h2>File Structure</h2>
A File Structure should be according to a required format that the operating system can understand. <br>

A file has a certain defined structure according to its type. <br>

A text file is a sequence of characters organized into lines. <br>

A source file is a sequence of procedures and functions. <br>

An object file is a sequence of bytes organized into blocks that are understandable by the machine. <br>

When operating system defines different file structures, it also contains the code to support these file structure. Unix, MS-DOS support minimum number of file structure. <br>

<h2>File Type</h2>
File type refers to the ability of the operating system to distinguish different types of file such as text files source files and binary files etc. Many operating systems support many types of files. Operating system like MS-DOS and UNIX have the following types of files - <br>

<h2>Ordinary files</h2>
These are the files that contain user information.
These may have text, databases or executable program.
The user can apply various operations on such files like add, modify, delete or even remove the entire file.
<h2>Directory files</h2>
These files contain list of file names and other information related to these files.
<h2>Special files</h2>
These files are also known as device files.
These files represent physical device like disks, terminals, printers, networks, tape drive etc.
These files are of two types - <br>

<h2>Character special files - </h2>data is handled character by character as in case of terminals or printers.

<h2>Block special files - </h2>data is handled in blocks as in the case of disks and tapes.

<h2>File Access Mechanisms</h2>
File access mechanism refers to the manner in which the records of a file may be accessed. There are several ways to access files - <br>

Sequential access <br>
Direct/Random access <br>
Indexed sequential access <br>

<h2>Sequential access </h2>
A sequential access is that in which the records are accessed in some sequence, i.e., the information in the file is processed in order, one record after the other. This access method is the most primitive one. Example: Compilers usually access files in this fashion.

<h2>Direct/Random access</h2>
Random access file organization provides, accessing the records directly.

Each record has its own address on the file with by the help of which it can be directly accessed for reading or writing.

The records need not be in any sequence within the file and they need not be in adjacent locations on the storage medium.

<h2>Indexed sequential access</h2>
This mechanism is built up on base of sequential access.
An index is created for each file which contains pointers to various blocks.
Index is searched sequentially and its pointer is used to access the file directly.
<h2>Space Allocation</h2>
Files are allocated disk spaces by operating system. Operating systems deploy following three main ways to allocate disk space to files- <br>

Contiguous Allocation <br>
Linked Allocation <br>
Indexed Allocation <br>
Contiguous Allocation
Each file occupies a contiguous address space on disk. <br>
Assigned disk address is in linear order. <br>
Easy to implement. <br>
External fragmentation is a major issue with this type of allocation technique. <br>
Linked Allocation <br>
Each file carries a list of links to disk blocks. <br>
Directory contains link / pointer to first block of a file. <br>
No external fragmentation <br>
Effectively used in sequential access file. <br>
Inefficient in case of direct access file. <br>
Indexed Allocation <br>
Provides solutions to problems of contiguous and linked allocation. <br>
A index block is created having all pointers to files. <br>
Each file has its own index block which stores the addresses of disk space occupied by the file. <br>
Directory contains the addresses of index blocks of files. <br>
</body>
</html>